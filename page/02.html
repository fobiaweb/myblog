---
layout: page
title:  "2. Архитектура"
---


		<p>Эта глава даст общее представление об архитектуре, терминлогии и некоторых ограничениях Doctrine 2. Очень рекомендуем внимательно к ней отнестись.</p>
<div id="toc_container" class="no_bullets">
<p class="toc_title">Содержание</p>
<ul class="toc_list">
<li>
<a href="#21_Doctrine">2.1. Сущности Doctrine</a><ul>
<li><a href="#211">2.1.1. Возможные состояния сущностей</a></li>
<li><a href="#212">2.1.2. Хранимые свойства сущности</a></li>
<li><a href="#213">2.1.3. Сериализация сущностей</a></li>
</ul>
</li>
<li>
<a href="#22_EntityManager">2.2. EntityManager</a><ul>
<li><a href="#221">2.2.1. Модель отложенных транзакций</a></li>
<li><a href="#222_Unit_of_Work">2.2.2. Паттерн Unit of Work</a></li>
</ul>
</li>
</ul>
</div>
<h1><span id="21_Doctrine">2.1. Сущности Doctrine</span></h1>
<p>Сущность — легковесный хранимый в БД объект из предметной области вашего приложения. Сущностью может являться любой <em>PHP</em> объект, который обладает следующими особенностями:</p>
<p>Сущность не должна быть финальным (<em>final</em>) классом или иметь финальные методы.</p>
<p>Все хранимые свойства класса сущности должны быть либо закрытыми (<em>private</em>), либо защищенными (<em>protected</em>), в противном случае “ленивая загрузка” будет работать некорректно. О ленивой загрузке будет сказано позднее.</p>
<p>В классе сущности не должно быть метода <em>__clone,</em> либо определять его нужно с осторожностью.</p>
<p>То же самое касается метода <em>__wakeup</em>. Постарайтесь вместо него использовать интерфейс <em>Serializable</em>.</p>
<p>Если две сущности связаны между собой наследованием (напрямую, либо косвенно), у них не должно быть свойств с одинаковыми именами. Так что, если, например, некая сущность <em>B</em> наследуется от сущности <em>A</em>, то у нее не должно быть свойства с теми же именами, которые уже есть в <em>A</em> (которые наследовалось от <em>A</em> к <em>B</em>).</p>
<p>В сущности нельзя использовать функцию <em>func_get_args()</em> для того, чтобы узнать параметры вызова. Сгенерированные классы прокси не поддерживают этот подход по причине проблем с производительностью, так что ваш код может работать некорректно.</p>
<p>Сущности поддерживают наследование, полиморфизм для своих связей и запросов. Сущностями могут быть как абстрактные, так и обычные классы. Сущности могут наследоваться как от других сущностей, так и от обычных классов. И, наоборот, обычный класс можно запросто наследовать от сущности.</p>
<blockquote><p>Замечание по поводу конструкторов. Конструктор класса сущности будет вызван лишь когда вы сами конструируете экземпляр этого класса с помощью оператора <strong>new</strong>. Сама Doctrine никогда не вызывает конструкторы сущностей, так что можете использовать их для собственных задач и передавать им любые аргументы.</p></blockquote>
<h2><span id="211">2.1.1. Возможные состояния сущностей</span></h2>
<p>Экземпляр определенной сущности может быть иметь из четырех возможных типов: <em>NEW</em>, <em>MANAGED</em>, <em>DETACHED</em> и <em>REMOVED</em>. <em>(перевод сознательно опущен)</em></p>
<p><em>NEW</em>. Сущность в этом состоянии пока не имеет своего постоянного идентификатора в хранилище, и пока никак не связана с менеджером сущностей (<em>EntityManager</em>) и компонентом <em>UnitOfWork</em> (например, она была только что создана оператором <em>new</em>).</p>
<p><em>MANAGED</em>. Существующая сущность со своим идентификатором, находящаяся под управление менеджера сущностей <em>EntityManager</em>.</p>
<p><em>DETACHED</em>. Сущность, идентификатор которой больше не связан с менеджером сущностей или компонентом <em>UnitOfWork</em>.</p>
<p><em>REMOVED</em>. Сущность со своим постоянным идентификатором, связанная с <em>EntityManager</em>, которая будет удалена из базы данных при завершении транзакции.</p>
<h2><span id="212">2.1.2. Хранимые свойства сущности</span></h2>
<p>Текущее состояние сущности определяется специальными “хранимыми” членами ее экземпляра (они помечаются специальным образом). Доступ к таким переменным должен осуществляться только самими экземпляром объекта сущности с помощью ее методов и никак иначе. Доступ извне к таким полям должен быть закрыт. Обращаться снаружи к ним можно лишь через методы-члены экземпляра класса, например через методы-аксессоры (getter/setter) или другим подобным образом.</p>
<p>Поля-коллекции сущности должны быть определены в соответствии с интерфейсом <em>Doctrine\Common\Collections\Collection</em>. Типы коллекций можно использовать для инициализации полей и свойств пока сущность еще не сохранена в базе данных. После того как сущностью станет управляемой (<em>MANAGED</em>) или будет отсоединена (<em>DETACHED</em>), доступ к ней должен предоставляться через этот интерфейс.</p>
<h2><span id="213">2.1.3. Сериализация сущностей</span></h2>
<p>Не рекомендуется использовать сериализацию сущностей, потому как это может породить определенные проблемы, по крайней мере пока она будет содержать ссылки на объекты “прокси” или находиться под управлением <em>EntityManager</em>. Если вы все же решите сериализовать или де-сериализовать сущность, которая все еще содержит ссылки на прокси-объекты, то могут появиться проблемы с приватными свойствами из-за технических ограничений. Прокси-объекты определяют метод <em>__sleep</em>, который не может вернуть имена приватных членов родительских классов. С другой стороны реализовывать интерфейс <em>Serializable</em> тоже не решение, потому что тут нас ждут потенциальные проблемы с циклическими ссылками (пока мы не нашли другого пути, так что если вы знаете больше, сообщите).</p>
<h1><span id="22_EntityManager">2.2. EntityManager</span></h1>
<p>Класс <em>EntityManager</em> — центральное звено <em>ORM</em> в <em>Doctrine 2</em>. <em>EntityManager</em> позволяет управлять хранимыми объектами и запрашивать их из хранилища.</p>
<h2><span id="221">2.2.1. Модель отложенных транзакций</span></h2>
<p>В <em>EntityManager</em> и <em>UnitOfWork</em> применяется стратегия под названием “отложенные транзакции”, которая откладывает исполнение <em>SQL</em>-запросов до поры до времени, чтобы затем выполнить их максимально эффективно при завершении транзакции, таким образом, что все блокировки на запись смогут быть быстро освобождены. Представьте себе, что <em>Doctrine</em> это инструмент для синхронизации сущестующих объектов в памяти с базой данных, которая происходит последовательно и небольшиим порциями. Работайте с вашими объектами, изменяйте их, а когда закончите вызовите метод <em>EntityManager#flush()</em> и все изменения будут сохранены.</p>
<h2><span id="222_Unit_of_Work">2.2.2. Паттерн Unit of Work</span></h2>
<p>Внутри <em>EntityManager</em> используется механизм <em>UnitOfWork</em>, который представляет собой реализацию одноименного паттерна <a href="http://martinfowler.com/eaaCatalog/unitOfWork.html" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://martinfowler.com']);">Unit of Work</a>. Он отслеживает все изменения данных в процессе работы и сохраняет их при исполнении транзакции через метод вроде <em>flush()</em>. Врядли вам придется работать напрямую с <em>UnitOfWork</em>, в основном все задачи будут решаться через класс <em>EntityManager</em>.</p>
<div align="left"><div class="sharexyWidgetNoindexUniqueClassName"><div id="shr_63684471"></div></div></div>
<div class="yarpp-related yarpp-related-none">
</div>
			

<div class="row pager">
<nav>
  <ul class="pager">
    <li class="previous"><a href="{{ "/page/01/" | prepend: site.baseurl }}"><span aria-hidden="true">&larr;</span> Назад</a></li>
    <li class="next"><a href="{{ "/page/03/" | prepend: site.baseurl }}">Далее <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>
</div>