---
layout: page
title:  "4. Часто задаваемые вопросы"
---


		
<p>Этот раздел постоянно пополняется. От вас приходит много вопросов, на многие из них мы не отвечаем, но помним о чем спрашивают чаще всего. Если у вас есть вопрос, подписывайтесь на рассылку или подключайтесь в <em>IRC</em> к каналу <em>#doctrine</em>.</p>
<div id="toc_container" class="no_bullets">
<p class="toc_title">Содержание</p>
<ul class="toc_list">
<li>
<a href="#41">4.1. Схема базы данных</a><ul><li><a href="#411___COLLATION__MySQL">4.1.1. Как установить кодировку и COLLATION для таблиц MySQL?</a></li></ul>
</li>
<li>
<a href="#42">4.2. Классы сущностей</a><ul>
<li><a href="#421__-___NULL">4.2.1. Обращаюсь к переменной-члену, а мне возвращается значение NULL, что не так?</a></li>
<li><a href="#422">4.2.2. Как добавить для столбца значение по умолчанию?</a></li>
</ul>
</li>
<li>
<a href="#43">4.3. Отображения</a><ul><li><a href="#431__em-gtflush">4.3.1. При выполнении $em-&gt;flush() появляются ошибки, связанные с нарушением уникальности данных</a></li></ul>
</li>
<li>
<a href="#44">4.4. Связи</a><ul>
<li><a href="#441__InvalidArgumentException_nbsp_A_new_entity_was_found_through_the_relationship">4.4.1. Мне выдается исключение InvalidArgumentException  с сообщением “A new entity was found through the relationship..”. Что не так?</a></li>
<li><a href="#442">4.4.2. Могу ли я как-то отфильтровать связанный с сущностью набор данных?</a></li>
<li><a href="#443__clear__8220_8221">4.4.3. После вызова метода clear() на наборе типа “один ко многим”, сущности почему-то не были удалены</a></li>
<li><a href="#444____8220_8221">4.4.4. Как добавить дополнительные столбцы к связи вида “один ко многим”?</a></li>
<li><a href="#445">4.4.5. Можно ли осуществлять постраничную выборку из присоединенных коллекций?</a></li>
<li><a href="#446____fetch-joins">4.4.6. Почему постраничная выборка некорректно работает с соединениями (fetch-joins)?</a></li>
</ul>
</li>
<li>
<a href="#45">4.5. Наследование</a><ul>
<li><a href="#451___Doctrine_2">4.5.1. Можно ли применять наследование в Doctrine 2?</a></li>
<li><a href="#452_Doctrine">4.5.2. Почему Doctrine не создает прокси объекты для иерархии классов?</a></li>
</ul>
</li>
<li>
<a href="#46_EntityGenerator">4.6. EntityGenerator</a><ul>
<li><a href="#461_EntityGenerator">4.6.1. Почему EntityGenerator не делает ту или иную вещь?</a></li>
<li><a href="#462_EntityGenerator">4.6.2. Почему EntityGenerator некорректно работает с иерархиями?</a></li>
</ul>
</li>
<li>
<a href="#47">4.7. Производительность</a><ul><li><a href="#471_____8220_8221___SQL">4.7.1. Почему когда я обращаюсь к данным через отношение “один к одному” это всякий раз порождает SQL запрос?</a></li></ul>
</li>
<li>
<a href="#48_DQL">4.8. Язык DQL</a><ul>
<li><a href="#481__DQL">4.8.1. Что представляет собой DQL?</a></li>
<li><a href="#482__DQL____ORDER_BY_RAND">4.8.2. Можно ли в DQL выполнить сортировку по заданной функции (например, ORDER BY RAND())?</a></li>
</ul>
</li>
</ul>
</div>
<h1><span id="41">4.1. Схема базы данных</span></h1>
<h2><span id="411___COLLATION__MySQL">4.1.1. Как установить кодировку и COLLATION для таблиц MySQL?</span></h2>
<p>Кодировку нельзя установить через аннотации и файлы XML- или YAML- отображений. Для настройки базы на работу с определенной кодировкой нужно установить ее как кодировку по-умолчанию в конфигурации MySQL, либо указать эти параметры при создании таблиц. В этом случае они будут автоматически применяться ко всем создаваемым таблицам и столбцам.</p>
<h1><span id="42">4.2. Классы сущностей</span></h1>
<h2><span id="421__-___NULL">4.2.1. Обращаюсь к переменной-члену, а мне возвращается значение NULL, что не так?</span></h2>
<p>Похоже вы объявили переменную как публичную (public), тем самым нарушив одно из ограничений, накладываемых на сущности. Для корректной работы объектов прокси хранимые переменные-члены у сущности должны быть объявлены как приватные или защищенные.</p>
<h2><span id="422">4.2.2. Как добавить для столбца значение по умолчанию?</span></h2>
<p><em>Doctrine</em> не поддерживает установку значений по умолчанию для столбцов как это делает в язык SQL через ключевое слово <em>DEFAULT</em>. Однако, это и не нужно, просто используйте для этого языковыми конструкции PHP:</p>
<div class="codecolorer-container php odiszapc" style="overflow:auto;white-space:nowrap;"><div class="php codecolorer">
<span class="kw2">class</span> User<br><span class="br0">{</span><br>
    <span class="kw2">const</span> STATUS_DISABLED <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span><br>
    <span class="kw2">const</span> STATUS_ENABLED <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span><br><br>
    <span class="kw2">private</span> <span class="re0">$algorithm</span> <span class="sy0">=</span> <span class="st0">"sha1"</span><span class="sy0">;</span><br>
    <span class="kw2">private</span> <span class="re0">$status</span> <span class="sy0">=</span> <span class="kw2">self</span><span class="sy0">:</span>STATUS_DISABLED<span class="sy0">;</span><br><span class="br0">}</span>
</div></div>
<h1><span id="43">4.3. Отображения</span></h1>
<h2><span id="431__em-gtflush">4.3.1. При выполнении $em-&gt;flush() появляются ошибки, связанные с нарушением уникальности данных</span></h2>
<p><em>Doctrine</em> не проверяет не добавляете ли вы в базу данных сущности с уже дублирующимися ключами <em>PRIMARY</em>, или не добавляете ли вы дважды  в коллекцию одну и ту же сущность. Если есть какие-то опасения на этот счет, всегда можно сделать соответствующую проверку перед вызовом <em>$em-&gt;flush()</em>.</p>
<p>В <a href="http://www.symfony.com/" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://www.symfony.com']);">Symfony2</a> для этого существует соответствующий компонент под названием <em>Unique Entity Validato</em>r.</p>
<p>Проверить содержит ли коллекция заданную сущность можно с помощью метода <em>$collection-&gt;contains($entity)</em>. Для коллекции с параметром <em>FETCH</em> равным <em>LAZY</em> этот метод просто инициализирует коллекцию, однако если <em>FETCH</em> равен <em>EXTRA_LAZY</em>, то для проверки принадлежности Doctrine выполнит <em>SQL</em>-запросы.</p>
<h1><span id="44">4.4. Связи</span></h1>
<h2><span id="441__InvalidArgumentException_nbsp_A_new_entity_was_found_through_the_relationship">4.4.1. Мне выдается исключение InvalidArgumentException  с сообщением “A new entity was found through the relationship..”. Что не так?</span></h2>
<p>Это исключение выбрасывается при исполнении метода <em>EntityManager#flush()</em> в случае, если в общей схеме данных существует объект, содержащий ссылку на некоторый объект, неизвестный <em>Doctrine</em>. Чтобы было проще понять, представьте, например, что вы загрузили из базы данных сущность пользователя <em>(User)</em> со своим идентификатором, затем создали новый объект и привязали его к объекту <em>User</em> через одну из существующих у него взаимосвязей. Затем, если вы вызовете <em>EntityManager#flush()</em>, не сообщив об свежесозданном объекте <em>Doctrine</em> с помощью метода <em>EntityManager#persist($newObject)</em>, будет выброшено такое исключение.</p>
<p>Решить проблему можно двумя путями:</p>
<ol>
<li>Предварительно вызвать метод <em>EntityManager#persist($newObject)</em> для вновь созданного объекта</li>
<li>Использовать свойство <em>cascade=persist</em> для связи, содержащей новый объект</li>
</ol>
<h2><span id="442">4.4.2. Могу ли я как-то отфильтровать связанный с сущностью набор данных?</span></h2>
<p>Такой возможности нет ни в версии<em> Doctrine 2.0</em>, ни в <em>2.1</em>. Для фильтрации набора сущностей лучше использовать возможности DQL.</p>
<h2><span id="443__clear__8220_8221">4.4.3. После вызова метода clear() на наборе типа “один ко многим”, сущности почему-то не были удалены</span></h2>
<p>Это ожидаемое поведение, связанное с концепции обратной и владеющей сторон связи, и тем, как с ними работает движок <em>Doctrine</em>. Когда сторона взаимосвязи “один ко многим” объявляется обратной, это означает, что Doctrine перестает воспринимать все изменения сущности, внесенные по эту сторону связи.</p>
<p>В качестве замены методу clear() можно использовать перебор по коллекции и установить ссылку на владеющей стороне отношения “многие к одному” в <em>NULL</em>, тем самым все сущности будут выброшены из коллекции. После этого будут выполнены соответствующие UPDATE запросы к базе данных .</p>
<h2><span id="444____8220_8221">4.4.4. Как добавить дополнительные столбцы к связи вида “один ко многим”?</span></h2>
<p>В качестве столбцов в определении таблицы для связи “один ко многим” допускается использовать только внешние ключи. Для добавления в такие связи дополнительных столбцов есть возможность использования внешних ключей как первичных (primary). Такая фича появилась в <em>Doctrine 2.1</em>.</p>
<p>Как это сделать читайте в <a href="http://www.doctrine-project.org/docs/orm/2.1/en/tutorials/composite-primary-keys.html" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://www.doctrine-project.org']);">обучалке по составным первичным ключам</a>.</p>
<h2><span id="445">4.4.5. Можно ли осуществлять постраничную выборку из присоединенных коллекций?</span></h2>
<p>Если вам нужно выражение DQL, которое может это сделать, мы вас огорчим, нет простого способа итерации по такой коллекции с помощью оператора LIMIT.</p>
<p><em>Doctrine</em> не предоставляет решения “из коробки”, однако существует несколько расширений, позволяющих это сделать:</p>
<ol>
<li><a href="http://github.com/beberlei/DoctrineExtensions" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://github.com']);">DoctrineExtensions</a></li>
<li><a href="http://github.com/whiteoctober/pagerfanta" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://github.com']);">Pagerfanta</a></li>
</ol>
<h2><span id="446____fetch-joins">4.4.6. Почему постраничная выборка некорректно работает с соединениями (fetch-joins)?</span></h2>
<p>Для ограничения результирующего набора данных движок постраничной выборки в <em>Doctrine</em> использует ключевое слово <em>LIMIT</em> (или его эквивалент). Однако, когда вы выполняете JOIN запрос, он не возвращает верное число записей, т.к. соединения через связи вида “один ко многим” и “многие ко многим” в качестве результирующего количества строк возвращают произведение числа строк на число связанных сущностей.</p>
<blockquote><p>Примечание переводчика: простите, слишком сложно перевести. Оригинал:<br>
Pagination in Doctrine uses a LIMIT clause (or vendor equivalent) to restrict the results. However when fetch-joining this is not returning the correct number of results since joining with a one-to-many or many-to-many association muliplies the number of rows by the number of associated entities.</p></blockquote>
<p>Для решения проблемы смотрите предыдущий вопрос .</p>
<h1><span id="45">4.5. Наследование</span></h1>
<h2><span id="451___Doctrine_2">4.5.1. Можно ли применять наследование в Doctrine 2?</span></h2>
<p>Да, допускается наследование применительно как к единичным, так и присоединенным таблицам.</p>
<p>Детали описаны в соответствующей главе.</p>
<h2><span id="452_Doctrine">4.5.2. Почему Doctrine не создает прокси объекты для иерархии классов?</span></h2>
<p>Когда в сущности создается связь с родительским классом вида “многие к одному” или “один к одному”, <em>Doctrine</em> не может определить какой из классов в действительности выступает в качестве “внешнего ключа”. Чтобы выяснить это, <em>Doctrine</em> должна выполнить <em>SQL</em> запрос для поиска этой информации в базе данных.</p>
<h1><span id="46_EntityGenerator">4.6. EntityGenerator</span></h1>
<h2><span id="461_EntityGenerator">4.6.1. Почему EntityGenerator не делает ту или иную вещь?</span></h2>
<p><em>EntityGenerator</em> не является полноценным генератором кода, решающим любые задачи. Генерация кода отныне не является основным приоритетом <em>Doctrine 2</em> (в отличие от <em>Doctrine 1</em>). <em>EntityGenerator</em> конечно помогает в работе, но это не панацея.</p>
<h2><span id="462_EntityGenerator">4.6.2. Почему EntityGenerator некорректно работает с иерархиями?</span></h2>
<p>Дело в том, что <em>EntityGenerator</em> не может правильно угадать взаимоотношения в иерархии классов. Вот почему создание наследуемых сущностей затруднено и пока не работает как нужно. Обрабатывать подобные ситуации вам нужно будет вручную.</p>
<h1><span id="47">4.7. Производительность</span></h1>
<h2><span id="471_____8220_8221___SQL">4.7.1. Почему когда я обращаюсь к данным через отношение “один к одному” это всякий раз порождает SQL запрос?</span></h2>
<p>Если <em>Doctrine</em> обнаружила, что обращение к данным происходит с обратной стороны связи (inverse side), то для загрузки целевого объекта будет выполнен дополнительный запрос. Так происходит потому что нельзя определить, вдруг там вообще нет никакого объекта (стоит NULL), или там прокси-объект, а какой у него идентификатор одному богу известно.</p>
<p>Чтобы избежать этой проблемы, используйте запрос который сразу получает всю необходимую информацию.</p>
<h1><span id="48_DQL">4.8. Язык DQL</span></h1>
<h2><span id="481__DQL">4.8.1. Что представляет собой DQL?</span></h2>
<p><em>DQL</em> это язык, очень похожий на <em>SQL</em>, имеющий ряд особенностей:</p>
<ol>
<li>Вместо названия таблиц и столбцов он использует названия классов и их полей, абстрагируясь между бэкендом и объектной моделью.</li>
<li>
<em>DQL</em> применяет информацию, хранящуюся в метаданных, давая возможность использовать сокращения при написании запросов. Например, если вы не указали оператор <em>ON</em> при соединении таблиц <em>Doctrine</em> сделает это за вас.</li>
<li>
<em>DQL</em> добавляет некоторую функциональность, связанную с управлением объектами и преобразованием их в запросы <em>SQL</em>. </li>
</ol>
<p>Конечно, есть и недостатки:</p>
<ol>
<li>Синтаксис его немного отличается от <em>SQL</em>, поэтому нужно четко уяснить различия.</li>
<li>Чтобы не зависеть от особенностей каждой конкретной СУБД, <em>DQL</em> реализует лишь общее подмножество <em>SQL</em>, поддерживаемое всеми продуктами.</li>
<li>В DQL нельзя использовать специфичный для конкретной СУБД функционал и различные оптимизации, пока они в явном виде не будет реализованы вами.</li>
<li>Для некоторых конструкций в <em>DQL</em> применяются вложенные <em>SELECT’ы</em>, которые в том же <em>MySQL</em> работают медленно.</li>
</ol>
<h2><span id="482__DQL____ORDER_BY_RAND">4.8.2. Можно ли в DQL выполнить сортировку по заданной функции (например, ORDER BY RAND())?</span></h2>
<p>Нет. Если вам нужен такой функционал, используйте низкоуровневые запросы или ищите другое решение. Имейте ввиду: начиная с 1000 записей в таблице сортировка вида <em>ORDER BY RAND()</em> выполняется крайне медленно.</p>
<div align="left"><div class="sharexyWidgetNoindexUniqueClassName"><div id="shr_59516577"></div></div></div>
<div class="yarpp-related yarpp-related-none">
</div>
			

<div class="row pager">
<nav>
  <ul class="pager">
    <li class="previous"><a href="{{ "/page/03/" | prepend: site.baseurl }}"><span aria-hidden="true">&larr;</span> Назад</a></li>
    <li class="next"><a href="{{ "/page/05/" | prepend: site.baseurl }}">Далее <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>
</div>